// Code generated by gotemplate. DO NOT EDIT.

// Copyright (c) 2015, Emir Pasic. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package treemap implements a map backed by red-black tree.
//
// Elements are ordered by key in the map.
//
// Structure is not thread safe.
//
// Reference: http://en.wikipedia.org/wiki/Associative_array
package types

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/eosspark/container/templates"
	rbt "github.com/eosspark/container/trees/redblacktree"
	"github.com/eosspark/container/utils"
	"github.com/eosspark/eos-go/common"
)

// template type Map(K,V,Compare)

func assertAccountNameUint32MapImplementation() {
	var _ templates.Map = (*AccountNameUint32Map)(nil)
}

// Map holds the elements in a red-black tree
type AccountNameUint32Map struct {
	isMulti bool
	tree    *rbt.Tree
}

// NewWith instantiates a tree map with the custom comparator.
func NewAccountNameUint32Map() *AccountNameUint32Map {
	return &AccountNameUint32Map{tree: rbt.NewWith(common.CompareName)}
}

func CopyFromAccountNameUint32Map(tm *AccountNameUint32Map) *AccountNameUint32Map {
	return &AccountNameUint32Map{tree: rbt.CopyFrom(tm.tree)}
}

func (m *AccountNameUint32Map) GetComparator() utils.Comparator {
	return m.tree.Comparator
}

// Put inserts key-value pair into the map.
// Key should adhere to the comparator's type assertion, otherwise method panics.
func (m *AccountNameUint32Map) Put(key common.AccountName, value uint32) {
	if m.isMulti {
		m.tree.MultiPut(key, value)
	} else {
		m.tree.Put(key, value)
	}
}

// Get searches the element in the map by key and returns its value or nil if key is not found in tree.
// Second return parameter is true if key was found, otherwise false.
// Key should adhere to the comparator's type assertion, otherwise method panics.
func (m *AccountNameUint32Map) Get(key common.AccountName) (value uint32, found bool) {
	if v, ok := m.tree.Get(key); ok {
		return v.(uint32), ok
	}
	return
}

// Remove removes the element from the map by key.
// Key should adhere to the comparator's type assertion, otherwise method panics.
func (m *AccountNameUint32Map) Remove(key common.AccountName) {
	if m.isMulti {
		m.tree.MultiRemove(key)
	} else {
		m.tree.Remove(key)
	}
}

// Empty returns true if map does not contain any elements
func (m *AccountNameUint32Map) Empty() bool {
	return m.tree.Empty()
}

// Size returns number of elements in the map.
func (m *AccountNameUint32Map) Size() int {
	return m.tree.Size()
}

// Keys returns all keys in-order
func (m *AccountNameUint32Map) Keys() []common.AccountName {
	keys := make([]common.AccountName, m.tree.Size())
	it := m.tree.Iterator()
	for i := 0; it.Next(); i++ {
		keys[i] = it.Key().(common.AccountName)
	}
	return keys
}

// Values returns all values in-order based on the key.
func (m *AccountNameUint32Map) Values() []uint32 {
	values := make([]uint32, m.tree.Size())
	it := m.tree.Iterator()
	for i := 0; it.Next(); i++ {
		values[i] = it.Value().(uint32)
	}
	return values
}

// Clear removes all elements from the map.
func (m *AccountNameUint32Map) Clear() {
	m.tree.Clear()
}

// Min returns the minimum key and its value from the tree map.
// Returns nil, nil if map is empty.
func (m *AccountNameUint32Map) Min() (key common.AccountName, value uint32) {
	if node := m.tree.Left(); node != nil {
		return node.Key.(common.AccountName), node.Value.(uint32)
	}
	return
}

// Max returns the maximum key and its value from the tree map.
// Returns nil, nil if map is empty.
func (m *AccountNameUint32Map) Max() (key common.AccountName, value uint32) {
	if node := m.tree.Right(); node != nil {
		return node.Key.(common.AccountName), node.Value.(uint32)
	}
	return
}

// Each calls the given function once for each element, passing that element's key and value.
func (m *AccountNameUint32Map) Each(f func(key common.AccountName, value uint32)) {
	iterator := m.Iterator()
	for iterator.Next() {
		f(iterator.Key(), iterator.Value())
	}
}

// Map invokes the given function once for each element and returns a container
// containing the values returned by the given function as key/value pairs.
func (m *AccountNameUint32Map) Map(f func(key1 common.AccountName, value1 uint32) (common.AccountName, uint32)) *AccountNameUint32Map {
	newMap := &AccountNameUint32Map{tree: rbt.NewWith(m.tree.Comparator)}
	iterator := m.Iterator()
	for iterator.Next() {
		key2, value2 := f(iterator.Key(), iterator.Value())
		newMap.Put(key2, value2)
	}
	return newMap
}

// Select returns a new container containing all elements for which the given function returns a true value.
func (m *AccountNameUint32Map) Select(f func(key common.AccountName, value uint32) bool) *AccountNameUint32Map {
	newMap := &AccountNameUint32Map{tree: rbt.NewWith(m.tree.Comparator)}
	iterator := m.Iterator()
	for iterator.Next() {
		if f(iterator.Key(), iterator.Value()) {
			newMap.Put(iterator.Key(), iterator.Value())
		}
	}
	return newMap
}

// Any passes each element of the container to the given function and
// returns true if the function ever returns true for any element.
func (m *AccountNameUint32Map) Any(f func(key common.AccountName, value uint32) bool) bool {
	iterator := m.Iterator()
	for iterator.Next() {
		if f(iterator.Key(), iterator.Value()) {
			return true
		}
	}
	return false
}

// All passes each element of the container to the given function and
// returns true if the function returns true for all elements.
func (m *AccountNameUint32Map) All(f func(key common.AccountName, value uint32) bool) bool {
	iterator := m.Iterator()
	for iterator.Next() {
		if !f(iterator.Key(), iterator.Value()) {
			return false
		}
	}
	return true
}

// Find passes each element of the container to the given function and returns
// the first (key,value) for which the function is true or nil,nil otherwise if no element
// matches the criteria.
func (m *AccountNameUint32Map) Find(f func(key common.AccountName, value uint32) bool) (k common.AccountName, v uint32) {
	iterator := m.Iterator()
	for iterator.Next() {
		if f(iterator.Key(), iterator.Value()) {
			return iterator.Key(), iterator.Value()
		}
	}
	return
}

// Floor finds the floor key-value pair for the input key.
// In case that no floor is found, then both returned values will be nil.
// It's generally enough to check the first value (key) for nil, which determines if floor was found.
//
// Floor key is defined as the largest key that is smaller than or equal to the given key.
// A floor key may not be found, either because the map is empty, or because
// all keys in the map are larger than the given key.
//
// Key should adhere to the comparator's type assertion, otherwise method panics.
func (m *AccountNameUint32Map) Floor(key common.AccountName) (foundKey common.AccountName, foundValue uint32) {
	node, found := m.tree.Floor(key)
	if found {
		return node.Key.(common.AccountName), node.Value.(uint32)
	}
	return
}

// Ceiling finds the ceiling key-value pair for the input key.
// In case that no ceiling is found, then both returned values will be nil.
// It's generally enough to check the first value (key) for nil, which determines if ceiling was found.
//
// Ceiling key is defined as the smallest key that is larger than or equal to the given key.
// A ceiling key may not be found, either because the map is empty, or because
// all keys in the map are smaller than the given key.
//
// Key should adhere to the comparator's type assertion, otherwise method panics.
func (m *AccountNameUint32Map) Ceiling(key common.AccountName) (foundKey common.AccountName, foundValue uint32) {
	node, found := m.tree.Ceiling(key)
	if found {
		return node.Key.(common.AccountName), node.Value.(uint32)
	}
	return
}

// String returns a string representation of container
func (m *AccountNameUint32Map) String() string {
	str := "TreeMap\nmap["
	it := m.Iterator()
	for it.Next() {
		str += fmt.Sprintf("%v:%v ", it.Key(), it.Value())
	}
	return strings.TrimRight(str, " ") + "]"

}

// Iterator holding the iterator's state
type IteratorAccountNameUint32Map struct {
	iterator rbt.Iterator
}

// Iterator returns a stateful iterator whose elements are key/value pairs.
func (m *AccountNameUint32Map) Iterator() IteratorAccountNameUint32Map {
	return IteratorAccountNameUint32Map{iterator: m.tree.Iterator()}
}

// Next moves the iterator to the next element and returns true if there was a next element in the container.
// If Next() returns true, then next element's key and value can be retrieved by Key() and Value().
// If Next() was called for the first time, then it will point the iterator to the first element if it exists.
// Modifies the state of the iterator.
func (iterator *IteratorAccountNameUint32Map) Next() bool {
	return iterator.iterator.Next()
}

// Prev moves the iterator to the previous element and returns true if there was a previous element in the container.
// If Prev() returns true, then previous element's key and value can be retrieved by Key() and Value().
// Modifies the state of the iterator.
func (iterator *IteratorAccountNameUint32Map) Prev() bool {
	return iterator.iterator.Prev()
}

// Value returns the current element's value.
// Does not modify the state of the iterator.
func (iterator *IteratorAccountNameUint32Map) Value() uint32 {
	return iterator.iterator.Value().(uint32)
}

// Key returns the current element's key.
// Does not modify the state of the iterator.
func (iterator *IteratorAccountNameUint32Map) Key() common.AccountName {
	return iterator.iterator.Key().(common.AccountName)
}

// Begin resets the iterator to its initial state (one-before-first)
// Call Next() to fetch the first element if any.
func (iterator *IteratorAccountNameUint32Map) Begin() {
	iterator.iterator.Begin()
}

// End moves the iterator past the last element (one-past-the-end).
// Call Prev() to fetch the last element if any.
func (iterator *IteratorAccountNameUint32Map) End() {
	iterator.iterator.End()
}

// First moves the iterator to the first element and returns true if there was a first element in the container.
// If First() returns true, then first element's key and value can be retrieved by Key() and Value().
// Modifies the state of the iterator
func (iterator *IteratorAccountNameUint32Map) First() bool {
	return iterator.iterator.First()
}

// Last moves the iterator to the last element and returns true if there was a last element in the container.
// If Last() returns true, then last element's key and value can be retrieved by Key() and Value().
// Modifies the state of the iterator.
func (iterator *IteratorAccountNameUint32Map) Last() bool {
	return iterator.iterator.Last()
}

// ToJSON outputs the JSON representation of the map.
type pairAccountNameUint32Map struct {
	Key common.AccountName
	Val uint32
}

func (m *AccountNameUint32Map) MarshalJSON() ([]byte, error) {
	elements := make([]pairAccountNameUint32Map, 0, m.Size())
	it := m.Iterator()
	for it.Next() {
		elements = append(elements, pairAccountNameUint32Map{it.Key(), it.Value()})
	}
	return json.Marshal(&elements)
}

// FromJSON populates the map from the input JSON representation.
func (m *AccountNameUint32Map) UnmarshalJSON(data []byte) error {
	elements := make([]pairAccountNameUint32Map, 0)
	err := json.Unmarshal(data, &elements)
	if err == nil {
		m.Clear()
		for _, pair := range elements {
			m.Put(pair.Key, pair.Val)
		}
	}
	return err
}

type MultiAccountNameUint32Map struct {
	AccountNameUint32Map
}

func NewMultiAccountNameUint32Map() *MultiAccountNameUint32Map {
	return &MultiAccountNameUint32Map{AccountNameUint32Map{tree: rbt.NewWith(common.CompareName), isMulti: true}}
}

func (m *MultiAccountNameUint32Map) Get(key common.AccountName) (front, end IteratorAccountNameUint32Map) {
	lower, upper := m.tree.MultiGet(key)
	return IteratorAccountNameUint32Map{lower}, IteratorAccountNameUint32Map{upper}
}

func (m *MultiAccountNameUint32Map) LowerBound(key common.AccountName) *IteratorAccountNameUint32Map {
	if itr := m.tree.LowerBound(key); itr != m.tree.End() {
		return &IteratorAccountNameUint32Map{itr}
	}
	return nil
}

func (m *MultiAccountNameUint32Map) UpperBound(key common.AccountName) *IteratorAccountNameUint32Map {
	if itr := m.tree.UpperBound(key); itr != m.tree.End() {
		return &IteratorAccountNameUint32Map{itr}
	}
	return nil
}
