// Code generated by gotemplate. DO NOT EDIT.

package int

import (
	"github.com/eosspark/eos-go/common/container"
	"github.com/eosspark/eos-go/common/container/multiindex"
)

// template type HashedUniqueIndex(FinalIndex,FinalNode,SuperIndex,SuperNode,Value,Hash,KeyFunc)

type ByPrev struct {
	super *TestIndexBase      // index on the HashedUniqueIndex, IndexBase is the last super index
	final *TestIndex          // index under the HashedUniqueIndex, MultiIndex is the final index
	inner map[int]*ByPrevNode // use hashmap to safe HashedUniqueIndex's k/v(HashedUniqueIndexNode)
}

func (i *ByPrev) init(final *TestIndex) {
	i.final = final
	i.inner = map[int]*ByPrevNode{}
	i.super = &TestIndexBase{}
	i.super.init(final)
}

/*generic class*/

/*generic class*/

type ByPrevNode struct {
	super *TestIndexBaseNode // index-node on the HashedUniqueIndexNode, IndexBaseNode is the last super node
	final *TestIndexNode     // index-node under the HashedUniqueIndexNode, MultiIndexNode is the final index
	hash  int                // k of hashmap
}

/*generic class*/

/*generic class*/

func (i *ByPrev) GetSuperIndex() interface{} { return i.super }
func (i *ByPrev) GetFinalIndex() interface{} { return i.final }

func (n *ByPrevNode) GetSuperNode() interface{} { return n.super }
func (n *ByPrevNode) GetFinalNode() interface{} { return n.final }

func (n *ByPrevNode) value() *int {
	return n.super.value()
}

func (i *ByPrev) Size() int {
	return len(i.inner)
}

func (i *ByPrev) Empty() bool {
	return len(i.inner) == 0
}

func (i *ByPrev) clear() {
	i.inner = map[int]*ByPrevNode{}
	i.super.clear()
}

func (i *ByPrev) Insert(v int) (IteratorByPrev, bool) {
	fn, res := i.final.insert(v)
	if res {
		return i.makeIterator(fn), true
	}
	return i.End(), false
}

func (i *ByPrev) insert(v int, fn *TestIndexNode) (*ByPrevNode, bool) {
	hash := ByPrevHashFunc(v)
	node := ByPrevNode{hash: hash}
	if _, ok := i.inner[hash]; ok {
		container.Logger.Warn("#hash index insert failed")
		return nil, false
	}
	i.inner[hash] = &node
	sn, res := i.super.insert(v, fn)
	if res {
		node.final = fn
		node.super = sn
		return &node, true
	}
	delete(i.inner, hash)
	return nil, false
}

func (i *ByPrev) Find(k int) (IteratorByPrev, bool) {
	node, res := i.inner[k]
	if res {
		return IteratorByPrev{i, node, betweenByPrev}, true
	}
	return i.End(), false
}

func (i *ByPrev) Each(f func(key int, obj int)) {
	for k, v := range i.inner {
		f(k, *v.value())
	}
}

func (i *ByPrev) Erase(iter IteratorByPrev) {
	i.final.erase(iter.node.final)
}

func (i *ByPrev) erase(n *ByPrevNode) {
	delete(i.inner, n.hash)
	i.super.erase(n.super)
}

func (i *ByPrev) erase_(iter multiindex.IteratorType) {
	if itr, ok := iter.(IteratorByPrev); ok {
		i.Erase(itr)
	} else {
		i.super.erase_(iter)
	}
}

func (i *ByPrev) Modify(iter IteratorByPrev, mod func(*int)) bool {
	if _, b := i.final.modify(mod, iter.node.final); b {
		return true
	}
	return false
}

func (i *ByPrev) modify(n *ByPrevNode) (*ByPrevNode, bool) {
	delete(i.inner, n.hash)

	hash := ByPrevHashFunc(*n.value())
	if _, exist := i.inner[hash]; exist {
		container.Logger.Warn("#hash index modify failed")
		i.super.erase(n.super)
		return nil, false
	}

	i.inner[hash] = n

	if sn, res := i.super.modify(n.super); !res {
		delete(i.inner, hash)
		return nil, false
	} else {
		n.super = sn
	}

	return n, true
}

func (i *ByPrev) modify_(iter multiindex.IteratorType, mod func(*int)) bool {
	if itr, ok := iter.(IteratorByPrev); ok {
		return i.Modify(itr, mod)
	} else {
		return i.super.modify_(iter, mod)
	}
}

func (i *ByPrev) Values() []int {
	vs := make([]int, 0, i.Size())
	i.Each(func(key int, obj int) {
		vs = append(vs, obj)
	})
	return vs
}

type IteratorByPrev struct {
	index    *ByPrev
	node     *ByPrevNode
	position posByPrev
}

type posByPrev byte

const (
	//begin   = 0
	betweenByPrev = 1
	endByPrev     = 2
)

func (i *ByPrev) makeIterator(fn *TestIndexNode) IteratorByPrev {
	node := fn.GetSuperNode()
	for {
		if node == nil {
			panic("Wrong index node type!")

		} else if n, ok := node.(*ByPrevNode); ok {
			return IteratorByPrev{i, n, betweenByPrev}
		} else {
			node = node.(multiindex.NodeType).GetSuperNode()
		}
	}
}

func (i *ByPrev) End() IteratorByPrev {
	return IteratorByPrev{i, nil, endByPrev}
}

func (iter IteratorByPrev) Value() (v int) {
	if iter.position == betweenByPrev {
		return *iter.node.value()
	}
	return
}

func (iter IteratorByPrev) HasNext() bool {
	container.Logger.Warn("hashed index iterator is unmoveable")
	return false
}

func (iter IteratorByPrev) IsEnd() bool {
	return iter.position == endByPrev
}
